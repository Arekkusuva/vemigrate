use cdrs::authenticators::StaticPasswordAuthenticator;
use cdrs::cluster::session::{new as new_session, Session};
use cdrs::cluster::{ClusterTcpConfig, NodeTcpConfigBuilder, TcpConnectionPool};
use cdrs::load_balancing::RoundRobin;
use cdrs::query::QueryExecutor;
use cdrs::types::ByIndex;

use vemigrate::{self, MigrationRow};

use std::fmt::{Display, Error, Formatter};
use std::{error, fmt, io};

pub const SIMPLE_STRATEGY: &str = "SimpleStrategy";
pub const NETWORK_TOPOLOGY_STRATEGY: &str = "NetworkTopologyStrategy";

pub enum ReplicationStrategy {
    Simple,
    NetworkTopology,
}

impl ReplicationStrategy {
    pub fn from_str(val: &str) -> Option<Self> {
        match val {
            SIMPLE_STRATEGY => Some(ReplicationStrategy::Simple),
            NETWORK_TOPOLOGY_STRATEGY => Some(ReplicationStrategy::NetworkTopology),
            _ => None,
        }
    }
}

impl Default for ReplicationStrategy {
    fn default() -> Self {
        ReplicationStrategy::Simple
    }
}

impl Display for ReplicationStrategy {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error> {
        match *self {
            ReplicationStrategy::Simple => f.write_str(SIMPLE_STRATEGY),
            ReplicationStrategy::NetworkTopology => f.write_str(NETWORK_TOPOLOGY_STRATEGY),
        }
    }
}

pub type DbResult<T> = std::result::Result<T, DbError>;

#[derive(Debug)]
pub enum DbError {
    NoRows,
    Database(cdrs::Error),
    Io(io::Error),
}

impl error::Error for DbError {}

impl fmt::Display for DbError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            DbError::Io(ref e) => e.fmt(f),
            DbError::Database(ref e) => e.fmt(f),
            DbError::NoRows => f.write_str("no rows"),
        }
    }
}

impl From<io::Error> for DbError {
    fn from(err: io::Error) -> Self {
        DbError::Io(err)
    }
}

impl From<cdrs::Error> for DbError {
    fn from(err: cdrs::Error) -> Self {
        DbError::Database(err)
    }
}

impl Into<vemigrate::Error> for DbError {
    fn into(self) -> vemigrate::Error {
        vemigrate::Error::Store(Box::new(self))
    }
}

type DbSession = Session<RoundRobin<TcpConnectionPool<StaticPasswordAuthenticator>>>;

const QUERY_GET_ALL: &str = "select id, up from vemigrate.migrations";
const QUERY_STORE_ONE: &str = "insert into vemigrate.migrations (id,up) values (?, ?);";

pub struct Database {
    conn: DbSession,
}

impl Database {
    pub fn with_session(addr: &str, user: &str, password: &str) -> DbResult<Self> {
        let auth = StaticPasswordAuthenticator::new(user, password);
        let nodes = vec![NodeTcpConfigBuilder::new(addr, auth).build()];
        let cluster_config = ClusterTcpConfig(nodes);

        let conn = new_session(&cluster_config, RoundRobin::new())?;
        Ok(Self { conn })
    }

    pub fn initial_migration_up(
        replication_strategy: ReplicationStrategy,
        replication_factor: usize,
    ) -> String {
        format!(
            r#"-- This file is automatically generated by `vemigrate-cli`. Do not edit directly.
        create keyspace if not exists vemigrate with replication = {{ 'class' : '{}', 'replication_factor': {} }};
        create table if not exists vemigrate.migrations (
            id bigint,
            up boolean,
            primary key(id)
        ) WITH CLUSTERING ORDER BY (timestamp DESC);"#,
            replication_strategy, replication_factor
        )
    }

    pub fn initial_migration_down() -> String {
        "drop keyspace if exists vemigrate;".to_string()
    }
}

impl vemigrate::Store for Database {
    type StoreError = DbError;

    fn get_all(&self) -> DbResult<Option<Vec<MigrationRow>>> {
        self.conn
            .query_tw(QUERY_GET_ALL, false, false)?
            .get_body()?
            .into_rows()
            .ok_or(DbError::NoRows)?
            .into_iter()
            .map(|row| {
                Ok(MigrationRow {
                    id: row.by_index(0)?.ok_or(DbError::NoRows)?,
                    up: row.by_index(1)?.ok_or(DbError::NoRows)?,
                })
            })
            .collect::<DbResult<Vec<MigrationRow>>>()
            .map(|r| if r.is_empty() { None } else { Some(r) })
    }

    fn store_one(&self, id: i64, up: bool) -> DbResult<()> {
        self.conn
            .query_with_values_tw(QUERY_STORE_ONE, query_values!(id, up), false, false)
            .map_err(DbError::from)
            .map(|_| ())
    }

    fn exec(&self, q: &str) -> DbResult<()> {
        self.conn
            .query_tw(q, false, false)
            .map_err(DbError::from)
            .map(|_| ())
    }
}
